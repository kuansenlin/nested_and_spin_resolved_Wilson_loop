# Example of analyzing spin-resolved topology using the module "spin_resolved_analysis" for a model of 3D helical higher-order topological insulator (HOTI) with inversion and time-reversal symmetries
# The model can be found in Appendix D 5 of arXiv:2207.10099v1.
# In terms of the spin-resolved topology, this model of helical HOTI is in the time-reversal-doubled axion insulator regime
# The code is run using python3
# The code is run using pythtb version 1.7.2

# Before comparing the figures generated by this example code to figures in arXiv:2207.10099v1, user should note that
# in Appendix D 5 of arXiv:2207.10099v1 the coupling between the eight-band helical HOTI model and the eight
# trivial bands are chosen to be td = "1.0", while in this example code td is chosen to be "0.5" to avoid potential 
# surface energy gap closing, without affecting any analyses on the bulk spin-resolved topology.

# The calculations in this python file include
# 1. 3D bulk spin-sz band structure calculation corresponding to Fig. 4 (d) "Spin Bands" in the main text of arXiv:2207.10099v1
#    (eigenvalues of P(k)szP(k) where P(k) is the occupied band projector where P(k) here corresponds to P_6 in Fig. 24 (a) of the Supplementary Appendices of arXiv:2207.10099v1)
# 2. kz-directed spin-sz-resolved Wilson loop at kx = -pi, -0.5pi, 0, 0.5pi, pi planes for P_4 and P_6 in Fig. 24 (a) of the Supplementary Appendices of arXiv:2207.10099v1
#    (the results can be compared with Figs. 24 (c), (d), (f), (g), (i), (j) and Figs. 25 (b), (c), (e), (f), (h), (i) of the Supplementary Appendices of arXiv:2207.10099v1)
# 3. demonstration of a choice of Wannier windows to divide the spin-sz-resolved Wannier band energies into inner and outer parts
#    (note that in this example code we demonstrate the Wannier window by explicitly sorting all the spin-sz-resolved Wannier band energies, which is different from the demonstration in Fig. 25 of the Supplementary Appendices of arXiv:2207.10099v1)
# 4. nested spin-sz-resolved Wilson loop as a function of kx for \tilde{P}^{\pm}_{in} and \tilde{P}^{\pm}_{out} as in Fig. 25 of the Supplementary Appendices of arXiv:2207.10099v1

# Notice that the analyses of spin-resolved topology in this example code are all based on spin sz.

# Notice that in this example code, the nested spin-resolved Wilson loop eigenphases are obtained by doing Wilson loop first along kz and then along ky in the spin spectrum.
# Such nested spin-resolved Wilson loop eigenphases depend on both kx and kz. 
# And if the base point of kz is kz0 in the calculation of the first spin-resolved Wilson loop, then the nested spin-resolved Wilson loop eigenphases thus obtained depend on [kx,kz0].
# In this example code we have chosen kz0 = -0.5 in the reduced coordinate.

# Authors: Kuan-Sen Lin (UIUC Physics), Benjamin J. Wieder (University of Paris-Saclay), and Barry Bradlyn (UIUC Physics)

import numpy as np
import matplotlib.pyplot as plt
# plt.switch_backend('agg')
from pythtb import *
from nestedWilsonLib import * # import the nested Wilson loop library
from spin_resolved_analysis import * # in order to facilitate the analyses of spin-resolved topology
import timeit
import os

path_data="./helical_HOTI_3D_spin_resolved_analysis"
if not os.path.exists(path_data):
    os.mkdir(path_data)

########### Construct the model ###########

# Pauli matrices
sx = np.array([0,1,0,0],dtype=complex)
sy = np.array([0,0,1,0],dtype=complex)
sz = np.array([0,0,0,1],dtype=complex)
s0 = np.array([1,0,0,0],dtype=complex)

# parameters and the function to generate helical-HOTI model
cutoff = 10**(-10)
pi = np.pi
I = +1j

m1 = -3.0 
vx = 1.0 
vz = 1.0 
ux = 1.0 
uz = 1.0 
m2 = 0.3 
m3 = 0.2 
vy = 2.0 
mv1 = -0.4 
mv2 = 0.2 
vH = 1.2 
A_spin_mix = 0.5 # this is for the spin mixing term

f323 = 0.25 # this is for the term f323*tau_z mu_y sigma_z

# additional hopping parameters
t_a = 11.0
t_b = -0.5
t_c = 1.5
t_d = 0.5 # can tune t_d smaller, like 0.5, to avoid potential surface energy gap closing
# can tune t_d to 1.0 to facilitate the gapping of bulk Wilson loop spectrum

# lattice
u3x = 0.35
u3y = 0.15
u3z = 0.31
lat=[[1,0,0],[0,1,0],[0,0,1]]
x1 = [0,0,0]
x2 = [0,0,0]
x3 = [0,0,0]
x4 = [0,0,0]
x5 = [u3x,u3y,u3z]
x6 = [u3x,u3y,u3z]
x7 = [-u3x,-u3y,-u3z]
x8 = [-u3x,-u3y,-u3z]
orbs = [x1,x2,x3,x4,x5,x6,x7,x8] # this will be crucial when we form the V_G later on !!!!

# function to generate a pythtb model of helical HOTI coupled to trivial bands
def helicalHOTI():
    
    model=tb_model(3,3,lat,orbs,nspin=2)
    
    # onsite for m1, m3 and mv1
    model.set_onsite([m1,m1,-m1,-m1,0.0,0.0,0.0,0.0],mode="add")
    model.set_onsite([m3,-m3,-m3,m3,0.0,0.0,0.0,0.0],mode="add")
    model.set_onsite([mv1,-mv1,mv1,-mv1,0.0,0.0,0.0,0.0],mode="add")
    
    # add hopping with non-zero lattice vector displacement
    
    # for vx
    model.set_hop(0.5*vx,0,0,[-1,0,0],mode="add")
    model.set_hop(0.5*vx,1,1,[-1,0,0],mode="add")
    model.set_hop(-0.5*vx,2,2,[-1,0,0],mode="add")
    model.set_hop(-0.5*vx,3,3,[-1,0,0],mode="add")
    
    # for vy
    model.set_hop(0.5*vy,0,0,[0,-1,0],mode="add")
    model.set_hop(0.5*vy,1,1,[0,-1,0],mode="add")
    model.set_hop(-0.5*vy,2,2,[0,-1,0],mode="add")
    model.set_hop(-0.5*vy,3,3,[0,-1,0],mode="add")
    
    # for vz
    model.set_hop(0.5*vz,0,0,[0,0,-1],mode="add")
    model.set_hop(0.5*vz,1,1,[0,0,-1],mode="add")
    model.set_hop(-0.5*vz,2,2,[0,0,-1],mode="add")
    model.set_hop(-0.5*vz,3,3,[0,0,-1],mode="add")
    
    # for ux
    model.set_hop(1*ux/(2*I),0,3,[-1,0,0],mode="add")
    model.set_hop(-1*ux/(2*I),1,2,[-1,0,0],mode="add")
    model.set_hop(-1*ux/(2*I),2,1,[-1,0,0],mode="add")
    model.set_hop(1*ux/(2*I),3,0,[-1,0,0],mode="add")
    
    # for uz
    model.set_hop(-1*uz/(2*I),0,2,[0,0,-1],mode="add")
    model.set_hop(-1*uz/(2*I),1,3,[0,0,-1],mode="add")
    model.set_hop(-1*uz/(2*I),2,0,[0,0,-1],mode="add")
    model.set_hop(-1*uz/(2*I),3,1,[0,0,-1],mode="add")
    
    # for m2, be careful of this since this is the hopping within unit cell
    model.set_hop(m2,0,1,[0,0,0],mode="add")
    model.set_hop(-m2,2,3,[0,0,0],mode="add")
    
    # for mv2, be careful of this since this is the hopping within unit cell
    model.set_hop(mv2,0,1,[0,0,0],mode="add")
    model.set_hop(mv2,2,3,[0,0,0],mode="add")
    
    # for vH, be careful of this since this hopping is spin-dependent
    model.set_hop((-vH/(2*I))*(-I)*sz,0,2,[0,-1,0],mode="add")
    model.set_hop((-vH/(2*I))*(+I)*sz,1,3,[0,-1,0],mode="add")
    model.set_hop((-vH/(2*I))*(+I)*sz,2,0,[0,-1,0],mode="add")
    model.set_hop((-vH/(2*I))*(-I)*sz,3,1,[0,-1,0],mode="add")
    
    # add the spin mixing term
    model.set_hop((-A_spin_mix/(2*I))*(-I)*sx,0,2,[0,0,-1],mode="add")
    model.set_hop((-A_spin_mix/(2*I))*(-I)*sx,1,3,[0,0,-1],mode="add")
    model.set_hop((-A_spin_mix/(2*I))*(+I)*sx,2,0,[0,0,-1],mode="add")
    model.set_hop((-A_spin_mix/(2*I))*(+I)*sx,3,1,[0,0,-1],mode="add")
    
    # f323*tau_z mu_y sigma_z
    model.set_hop(f323*(-I)*sz,0,1,[0,0,0],mode="add")
    model.set_hop(f323*(+I)*sz,2,3,[0,0,0],mode="add")
    
    ############################# now add the hopping for the additional bands #############################
    
    # first do t_a, this will induce bonding and anti-bonding and is hopping within cell, so be careful
    model.set_hop(t_a,4,6,[0,0,0],mode="add")
    model.set_hop(t_a,5,7,[0,0,0],mode="add")
    
    # next do t_b, this is onsite energy for the additional orbitals
    model.set_onsite([0.0,0.0,0.0,0.0,t_b,t_b,t_b,t_b],mode="add")
    
    # next do t_c, this will cause energy splitting between x5 & x6 and x7 & x8
    # this is also on-site energy
    model.set_onsite([0.0,0.0,0.0,0.0,t_c,-t_c,t_c,-t_c],mode="add")
    
    # next do t_d, this will couple the additional orbitals to the original model
    model.set_hop(t_d,0,4,[0,0,0],mode="add")
    model.set_hop(t_d,0,5,[0,0,0],mode="add")
    model.set_hop(t_d,0,6,[0,0,0],mode="add")
    model.set_hop(t_d,0,7,[0,0,0],mode="add")
    
    model.set_hop(t_d,1,4,[0,0,0],mode="add")
    model.set_hop(t_d,1,5,[0,0,0],mode="add")
    model.set_hop(t_d,1,6,[0,0,0],mode="add")
    model.set_hop(t_d,1,7,[0,0,0],mode="add")
    
    return model

print("Construct the model\n")
my_model=helicalHOTI()

########### 3D bulk spin-sz bands ###########

print("Compute the 3D bulk spin-sz bands using get_PsP_evals from spin_resolved_analysis")

numkpts = 1001

GM = [0,0,0]
X = [0.5,0,0]
Y = [0,0.5,0]
S = [0.5,0.5,0]
Z = [0,0,0.5]
U = [0.5,0,0.5]
T = [0,0.5,0.5]
R = [0.5,0.5,0.5]

path=[GM,X,S,Y,GM,Z,U,R,T,Z,Y,T,U,X,S,R,GM]
label=(r'$\Gamma $',r'$X$',r'$S$',r'$Y$',r'$\Gamma$',r'$Z$',r'$U$',r'$R$',r'$T$',r'$Z$',r'$Y$',r'$T$',r'$U$',r'$X$',r'$S$',r'$R$',r'$\Gamma$')

(k_vec,k_dist,k_node) = my_model.k_path(path,numkpts,report=False)

spin_sz_evals=[]
start_time = timeit.default_timer()
for k in k_vec:
    spin_sz_evals.append(get_PsP_evals(model=my_model,spin_dir=[0,0,1],occ=[2,3,4,5,6,7],k=k))
print("--- %s seconds ---\n" % (timeit.default_timer() - start_time))

spin_sz_evals=np.array(spin_sz_evals)
spin_sz_evals=np.transpose(spin_sz_evals)

plt.figure()
for n in range(spin_sz_evals.shape[0]):
    plt.plot(k_dist,spin_sz_evals[n])
plt.xlim([np.min(k_dist),np.max(k_dist)])
plt.xlabel(r"$\mathbf{k}$",fontsize=20)
plt.ylabel(r"$P s_z P$ eigenvalue",fontsize=20)
plt.xticks(k_node,label,fontsize=20)
plt.yticks(fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/bulk_spin_sz_bands.pdf")
plt.close()

########### kz-directed spin-sz-resolved Wilson Loop calculation ###########

print("Now start kz-directed spin-sz-resolved Wilson loop calculation\n")

print("First consider P_4 as in Fig. 24 (a) of the Supplementary Appendices of arXiv:2207.10099v1")

print("Collect the eigenvectors of the projected spin operator using get_PsP_evecs from spin_resolved_analysis")

print("Consider only kx = -pi, -0.5pi, 0, 0.5pi, and 1.0pi planes")

start_time = timeit.default_timer()

N1=5
N2=31
N3=31
spin_dir=[0.0,0.0,1.0]
occ=[4,5,6,7]
occ_ind=len(occ)
Nt=my_model._nsta
k1_list=np.linspace(-0.5,0.5,num=N1,endpoint=True)
k2_list=np.linspace(-0.5,0.5,num=N2,endpoint=True)
k3_list=np.linspace(-0.5,0.5,num=N3,endpoint=True)
PsP_evecs=np.zeros((N1,N2,N3,Nt,Nt//2,2),dtype=complex)
for k1_ind in range(len(k1_list)):
    for k2_ind in range(len(k2_list)):
        for k3_ind in range(len(k3_list)):
            k1=k1_list[k1_ind]
            k2=k2_list[k2_ind]
            k3=k3_list[k3_ind]
            PsP_evecs[k1_ind,k2_ind,k3_ind]=get_PsP_evecs(my_model,spin_dir,occ,[k1,k2,k3])

print("--- %s seconds ---" % (timeit.default_timer() - start_time))

### Initiate the pythtb wave function array
PsP_wfs=wf_array(my_model,[N1,N2,N3])

### Fill the eigenstates of the projected spin operator to the pythtb wave function array
for k1_ind in range(N1):
    for k2_ind in range(N2):
        for k3_ind in range(N3):
            PsP_wfs[k1_ind,k2_ind,k3_ind]=PsP_evecs[k1_ind,k2_ind,k3_ind]
PsP_wfs.impose_pbc(0,0)
PsP_wfs.impose_pbc(1,1)
PsP_wfs.impose_pbc(2,2)

### Compute the spin-resolved wannier band basis and the spin-resolved wannier band energy
### Note the band indices are list(np.arange(occ_ind//2)) and list(np.arange(Nt-occ_ind//2,Nt))
### for the P_minus and P_plus Wannier band basis array
### The general idea is that the user can fill in any types of wave functions into the wave function array,
### but the user need to be careful about selecting the band indices when they start to initiate the wannier_band_basis_array

dir1=2
minus_wbbarr=wannier_band_basis_array(PsP_wfs,list(np.arange(occ_ind//2)),dir1) 
plus_wbbarr =wannier_band_basis_array(PsP_wfs,list(np.arange(Nt-occ_ind//2,Nt)),dir1) 

print("Compute the spin-resolved wannier band basis and the spin-resolved wannier band energy")

start_time = timeit.default_timer()
minus_wbbarr.solve_wannier_band_basis()
plus_wbbarr.solve_wannier_band_basis()
print("--- %s seconds ---\n" % (timeit.default_timer() - start_time))

# get the P_minus and P_plus Wannier band energy
minus_wbe=minus_wbbarr._wannier_band_energy
plus_wbe=plus_wbbarr._wannier_band_energy

### Plot out the results for P_minus Wilson loop

slice_grid=minus_wbe.shape[0]
plot_grid=minus_wbe.shape[1]
band_num=minus_wbe.shape[2]

k_ind=0
plt.figure(figsize=(5.2,5))
for i in range(band_num):
    plt.plot(minus_wbe[k_ind,:,i],'.',color='black')
plt.xlim([0,plot_grid-1])
plt.ylim([-np.pi,np.pi])
plt.xlabel(r"$k_y$",fontsize=20)
plt.ylabel(r"$k_z$-directed $\gamma_1^-$",fontsize=20)
plt.title(r"$P_4^-$, $k_x = {}\pi$".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ),fontsize=20)
plt.xticks([0,(plot_grid-1)/2.0,plot_grid-1],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/kz_directed_P_minus_Wannier_bands_of_P4_at_kx_{}pi.pdf".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ))
plt.close()

k_ind=(slice_grid-1)//2 - (slice_grid-1)//4
plt.figure(figsize=(5.2,5))
for i in range(band_num):
    plt.plot(minus_wbe[k_ind,:,i],'.',color='black')
plt.xlim([0,plot_grid-1])
plt.ylim([-np.pi,np.pi])
plt.xlabel(r"$k_y$",fontsize=20)
plt.ylabel(r"$k_z$-directed $\gamma_1^-$",fontsize=20)
plt.title(r"$P_4^-$, $k_x = {}\pi$".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ),fontsize=20)
plt.xticks([0,(plot_grid-1)/2.0,plot_grid-1],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/kz_directed_P_minus_Wannier_bands_of_P4_at_kx_{}pi.pdf".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ))
plt.close()

k_ind=(slice_grid-1)//2
plt.figure(figsize=(5.2,5))
for i in range(band_num):
    plt.plot(minus_wbe[k_ind,:,i],'.',color='black')
plt.xlim([0,plot_grid-1])
plt.ylim([-np.pi,np.pi])
plt.xlabel(r"$k_y$",fontsize=20)
plt.ylabel(r"$k_z$-directed $\gamma_1^-$",fontsize=20)
plt.title(r"$P_4^-$, $k_x = {}\pi$".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ),fontsize=20)
plt.xticks([0,(plot_grid-1)/2.0,plot_grid-1],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/kz_directed_P_minus_Wannier_bands_of_P4_at_kx_{}pi.pdf".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ))
plt.close()

k_ind=(slice_grid-1)//2 + (slice_grid-1)//4
plt.figure(figsize=(5.2,5))
for i in range(band_num):
    plt.plot(minus_wbe[k_ind,:,i],'.',color='black')
plt.xlim([0,plot_grid-1])
plt.ylim([-np.pi,np.pi])
plt.xlabel(r"$k_y$",fontsize=20)
plt.ylabel(r"$k_z$-directed $\gamma_1^-$",fontsize=20)
plt.title(r"$P_4^-$, $k_x = {}\pi$".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ),fontsize=20)
plt.xticks([0,(plot_grid-1)/2.0,plot_grid-1],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/kz_directed_P_minus_Wannier_bands_of_P4_at_kx_{}pi.pdf".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ))
plt.close()

k_ind=(slice_grid-1)
plt.figure(figsize=(5.2,5))
for i in range(band_num):
    plt.plot(minus_wbe[k_ind,:,i],'.',color='black')
plt.xlim([0,plot_grid-1])
plt.ylim([-np.pi,np.pi])
plt.xlabel(r"$k_y$",fontsize=20)
plt.ylabel(r"$k_z$-directed $\gamma_1^-$",fontsize=20)
plt.title(r"$P_4^-$, $k_x = {}\pi$".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ),fontsize=20)
plt.xticks([0,(plot_grid-1)/2.0,plot_grid-1],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/kz_directed_P_minus_Wannier_bands_of_P4_at_kx_{}pi.pdf".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ))
plt.close()

### Plot out the results for P_plus Wilson loop

slice_grid=plus_wbe.shape[0]
plot_grid=plus_wbe.shape[1]
band_num=plus_wbe.shape[2]

k_ind=0
plt.figure(figsize=(5.2,5))
for i in range(band_num):
    plt.plot(plus_wbe[k_ind,:,i],'.',color='black')
plt.xlim([0,plot_grid-1])
plt.ylim([-np.pi,np.pi])
plt.xlabel(r"$k_y$",fontsize=20)
plt.ylabel(r"$k_z$-directed $\gamma_1^+$",fontsize=20)
plt.title(r"$P_4^+$, $k_x = {}\pi$".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ),fontsize=20)
plt.xticks([0,(plot_grid-1)/2.0,plot_grid-1],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/kz_directed_P_plus_Wannier_bands_of_P4_at_kx_{}pi.pdf".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ))
plt.close()

k_ind=(slice_grid-1)//2 - (slice_grid-1)//4
plt.figure(figsize=(5.2,5))
for i in range(band_num):
    plt.plot(plus_wbe[k_ind,:,i],'.',color='black')
plt.xlim([0,plot_grid-1])
plt.ylim([-np.pi,np.pi])
plt.xlabel(r"$k_y$",fontsize=20)
plt.ylabel(r"$k_z$-directed $\gamma_1^+$",fontsize=20)
plt.title(r"$P_4^+$, $k_x = {}\pi$".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ),fontsize=20)
plt.xticks([0,(plot_grid-1)/2.0,plot_grid-1],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/kz_directed_P_plus_Wannier_bands_of_P4_at_kx_{}pi.pdf".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ))
plt.close()

k_ind=(slice_grid-1)//2
plt.figure(figsize=(5.2,5))
for i in range(band_num):
    plt.plot(plus_wbe[k_ind,:,i],'.',color='black')
plt.xlim([0,plot_grid-1])
plt.ylim([-np.pi,np.pi])
plt.xlabel(r"$k_y$",fontsize=20)
plt.ylabel(r"$k_z$-directed $\gamma_1^+$",fontsize=20)
plt.title(r"$P_4^+$, $k_x = {}\pi$".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ),fontsize=20)
plt.xticks([0,(plot_grid-1)/2.0,plot_grid-1],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/kz_directed_P_plus_Wannier_bands_of_P4_at_kx_{}pi.pdf".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ))
plt.close()

k_ind=(slice_grid-1)//2 + (slice_grid-1)//4
plt.figure(figsize=(5.2,5))
for i in range(band_num):
    plt.plot(plus_wbe[k_ind,:,i],'.',color='black')
plt.xlim([0,plot_grid-1])
plt.ylim([-np.pi,np.pi])
plt.xlabel(r"$k_y$",fontsize=20)
plt.ylabel(r"$k_z$-directed $\gamma_1^+$",fontsize=20)
plt.title(r"$P_4^+$, $k_x = {}\pi$".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ),fontsize=20)
plt.xticks([0,(plot_grid-1)/2.0,plot_grid-1],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/kz_directed_P_plus_Wannier_bands_of_P4_at_kx_{}pi.pdf".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ))
plt.close()

k_ind=(slice_grid-1)
plt.figure(figsize=(5.2,5))
for i in range(band_num):
    plt.plot(plus_wbe[k_ind,:,i],'.',color='black')
plt.xlim([0,plot_grid-1])
plt.ylim([-np.pi,np.pi])
plt.xlabel(r"$k_y$",fontsize=20)
plt.ylabel(r"$k_z$-directed $\gamma_1^+$",fontsize=20)
plt.title(r"$P_4^+$, $k_x = {}\pi$".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ),fontsize=20)
plt.xticks([0,(plot_grid-1)/2.0,plot_grid-1],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/kz_directed_P_plus_Wannier_bands_of_P4_at_kx_{}pi.pdf".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ))
plt.close()

print("Next consider P_6 as in Fig. 24 (a) of the Supplementary Appendices of arXiv:2207.10099v1, and the results will be used directly in the calculation of nested spin-resolved Wilson loop")

print("Collect the eigenvectors of the projected spin operator using get_PsP_evecs from spin_resolved_analysis")

start_time = timeit.default_timer()

N1=61
N2=31
N3=31
spin_dir=[0.0,0.0,1.0]
occ=[2,3,4,5,6,7]
occ_ind=len(occ)
Nt=my_model._nsta
k1_list=np.linspace(-0.5,0.5,num=N1,endpoint=True)
k2_list=np.linspace(-0.5,0.5,num=N2,endpoint=True)
k3_list=np.linspace(-0.5,0.5,num=N3,endpoint=True)
PsP_evecs=np.zeros((N1,N2,N3,Nt,Nt//2,2),dtype=complex)
for k1_ind in range(len(k1_list)):
    for k2_ind in range(len(k2_list)):
        for k3_ind in range(len(k3_list)):
            k1=k1_list[k1_ind]
            k2=k2_list[k2_ind]
            k3=k3_list[k3_ind]
            PsP_evecs[k1_ind,k2_ind,k3_ind]=get_PsP_evecs(my_model,spin_dir,occ,[k1,k2,k3])

print("--- %s seconds ---" % (timeit.default_timer() - start_time))

### Initiate the pythtb wave function array
PsP_wfs=wf_array(my_model,[N1,N2,N3])

### Fill the eigenstates of the projected spin operator to the pythtb wave function array
for k1_ind in range(N1):
    for k2_ind in range(N2):
        for k3_ind in range(N3):
            PsP_wfs[k1_ind,k2_ind,k3_ind]=PsP_evecs[k1_ind,k2_ind,k3_ind]
PsP_wfs.impose_pbc(0,0)
PsP_wfs.impose_pbc(1,1)
PsP_wfs.impose_pbc(2,2)

### Compute the spin-resolved wannier band basis and the spin-resolved wannier band energy
### Note the band indices as list(np.arange(occ_ind//2)) and list(np.arange(Nt-occ_ind//2,Nt))
### for the P_minus and P_plus Wannier band basis array
### The general idea is that the user can fill in any types of wave functions into the wave function array,
### but the user need to be careful about selecting the band indices when they start to initiate the wannier_band_basis_array

dir1=2
minus_wbbarr=wannier_band_basis_array(PsP_wfs,list(np.arange(occ_ind//2)),dir1) 
plus_wbbarr =wannier_band_basis_array(PsP_wfs,list(np.arange(Nt-occ_ind//2,Nt)),dir1) 

print("Compute the spin-resolved wannier band basis and the spin-resolved wannier band energy")

start_time = timeit.default_timer()
minus_wbbarr.solve_wannier_band_basis()
plus_wbbarr.solve_wannier_band_basis()
print("--- %s seconds ---" % (timeit.default_timer() - start_time))

# get the P_minus and P_plus Wannier band energy
minus_wbe=minus_wbbarr._wannier_band_energy
plus_wbe=plus_wbbarr._wannier_band_energy

### Plot out the results for P_minus Wilson loop

slice_grid=minus_wbe.shape[0]
plot_grid=minus_wbe.shape[1]
band_num=minus_wbe.shape[2]

k_ind=0
plt.figure(figsize=(5.2,5))
for i in range(band_num):
    plt.plot(minus_wbe[k_ind,:,i],'.',color='black')
plt.xlim([0,plot_grid-1])
plt.ylim([-np.pi,np.pi])
plt.xlabel(r"$k_y$",fontsize=20)
plt.ylabel(r"$k_z$-directed $\gamma_1^-$",fontsize=20)
plt.title(r"$P_6^-$, $k_x = {}\pi$".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ),fontsize=20)
plt.xticks([0,(plot_grid-1)/2.0,plot_grid-1],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/kz_directed_P_minus_Wannier_bands_of_P6_at_kx_{}pi.pdf".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ))
plt.close()

k_ind=(slice_grid-1)//2 - (slice_grid-1)//4
plt.figure(figsize=(5.2,5))
for i in range(band_num):
    plt.plot(minus_wbe[k_ind,:,i],'.',color='black')
plt.xlim([0,plot_grid-1])
plt.ylim([-np.pi,np.pi])
plt.xlabel(r"$k_y$",fontsize=20)
plt.ylabel(r"$k_z$-directed $\gamma_1^-$",fontsize=20)
plt.title(r"$P_6^-$, $k_x = {}\pi$".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ),fontsize=20)
plt.xticks([0,(plot_grid-1)/2.0,plot_grid-1],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/kz_directed_P_minus_Wannier_bands_of_P6_at_kx_{}pi.pdf".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ))
plt.close()

k_ind=(slice_grid-1)//2
plt.figure(figsize=(5.2,5))
for i in range(band_num):
    plt.plot(minus_wbe[k_ind,:,i],'.',color='black')
plt.xlim([0,plot_grid-1])
plt.ylim([-np.pi,np.pi])
plt.xlabel(r"$k_y$",fontsize=20)
plt.ylabel(r"$k_z$-directed $\gamma_1^-$",fontsize=20)
plt.title(r"$P_6^-$, $k_x = {}\pi$".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ),fontsize=20)
plt.xticks([0,(plot_grid-1)/2.0,plot_grid-1],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/kz_directed_P_minus_Wannier_bands_of_P6_at_kx_{}pi.pdf".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ))
plt.close()

k_ind=(slice_grid-1)//2 + (slice_grid-1)//4
plt.figure(figsize=(5.2,5))
for i in range(band_num):
    plt.plot(minus_wbe[k_ind,:,i],'.',color='black')
plt.xlim([0,plot_grid-1])
plt.ylim([-np.pi,np.pi])
plt.xlabel(r"$k_y$",fontsize=20)
plt.ylabel(r"$k_z$-directed $\gamma_1^-$",fontsize=20)
plt.title(r"$P_6^-$, $k_x = {}\pi$".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ),fontsize=20)
plt.xticks([0,(plot_grid-1)/2.0,plot_grid-1],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/kz_directed_P_minus_Wannier_bands_of_P6_at_kx_{}pi.pdf".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ))
plt.close()

k_ind=(slice_grid-1)
plt.figure(figsize=(5.2,5))
for i in range(band_num):
    plt.plot(minus_wbe[k_ind,:,i],'.',color='black')
plt.xlim([0,plot_grid-1])
plt.ylim([-np.pi,np.pi])
plt.xlabel(r"$k_y$",fontsize=20)
plt.ylabel(r"$k_z$-directed $\gamma_1^-$",fontsize=20)
plt.title(r"$P_6^-$, $k_x = {}\pi$".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ),fontsize=20)
plt.xticks([0,(plot_grid-1)/2.0,plot_grid-1],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/kz_directed_P_minus_Wannier_bands_of_P6_at_kx_{}pi.pdf".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ))
plt.close()

### Plot out the results for P_plus Wilson loop

slice_grid=plus_wbe.shape[0]
plot_grid=plus_wbe.shape[1]
band_num=plus_wbe.shape[2]

k_ind=0
plt.figure(figsize=(5.2,5))
for i in range(band_num):
    plt.plot(plus_wbe[k_ind,:,i],'.',color='black')
plt.xlim([0,plot_grid-1])
plt.ylim([-np.pi,np.pi])
plt.xlabel(r"$k_y$",fontsize=20)
plt.ylabel(r"$k_z$-directed $\gamma_1^+$",fontsize=20)
plt.title(r"$P_6^+$, $k_x = {}\pi$".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ),fontsize=20)
plt.xticks([0,(plot_grid-1)/2.0,plot_grid-1],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/kz_directed_P_plus_Wannier_bands_of_P6_at_kx_{}pi.pdf".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ))
plt.close()

k_ind=(slice_grid-1)//2 - (slice_grid-1)//4
plt.figure(figsize=(5.2,5))
for i in range(band_num):
    plt.plot(plus_wbe[k_ind,:,i],'.',color='black')
plt.xlim([0,plot_grid-1])
plt.ylim([-np.pi,np.pi])
plt.xlabel(r"$k_y$",fontsize=20)
plt.ylabel(r"$k_z$-directed $\gamma_1^+$",fontsize=20)
plt.title(r"$P_6^+$, $k_x = {}\pi$".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ),fontsize=20)
plt.xticks([0,(plot_grid-1)/2.0,plot_grid-1],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/kz_directed_P_plus_Wannier_bands_of_P6_at_kx_{}pi.pdf".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ))
plt.close()

k_ind=(slice_grid-1)//2
plt.figure(figsize=(5.2,5))
for i in range(band_num):
    plt.plot(plus_wbe[k_ind,:,i],'.',color='black')
plt.xlim([0,plot_grid-1])
plt.ylim([-np.pi,np.pi])
plt.xlabel(r"$k_y$",fontsize=20)
plt.ylabel(r"$k_z$-directed $\gamma_1^+$",fontsize=20)
plt.title(r"$P_6^+$, $k_x = {}\pi$".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ),fontsize=20)
plt.xticks([0,(plot_grid-1)/2.0,plot_grid-1],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/kz_directed_P_plus_Wannier_bands_of_P6_at_kx_{}pi.pdf".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ))
plt.close()

k_ind=(slice_grid-1)//2 + (slice_grid-1)//4
plt.figure(figsize=(5.2,5))
for i in range(band_num):
    plt.plot(plus_wbe[k_ind,:,i],'.',color='black')
plt.xlim([0,plot_grid-1])
plt.ylim([-np.pi,np.pi])
plt.xlabel(r"$k_y$",fontsize=20)
plt.ylabel(r"$k_z$-directed $\gamma_1^+$",fontsize=20)
plt.title(r"$P_6^+$, $k_x = {}\pi$".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ),fontsize=20)
plt.xticks([0,(plot_grid-1)/2.0,plot_grid-1],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/kz_directed_P_plus_Wannier_bands_of_P6_at_kx_{}pi.pdf".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ))
plt.close()

k_ind=(slice_grid-1)
plt.figure(figsize=(5.2,5))
for i in range(band_num):
    plt.plot(plus_wbe[k_ind,:,i],'.',color='black')
plt.xlim([0,plot_grid-1])
plt.ylim([-np.pi,np.pi])
plt.xlabel(r"$k_y$",fontsize=20)
plt.ylabel(r"$k_z$-directed $\gamma_1^+$",fontsize=20)
plt.title(r"$P_6^+$, $k_x = {}\pi$".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ),fontsize=20)
plt.xticks([0,(plot_grid-1)/2.0,plot_grid-1],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/kz_directed_P_plus_Wannier_bands_of_P6_at_kx_{}pi.pdf".format( round(2.0*(-0.5+k_ind/(slice_grid-1)),4) ))
plt.close()

print("Plotting the demonstration of a choice of Wannier windows")

window_1=-0.02*np.pi
window_2=0.02*np.pi

plt.figure(figsize=(6,10.5))
plt.plot(np.sort(minus_wbe.flatten()),'.',color='black')
plt.axhline(y=window_2,color='C1',ls='--',label=r"${}\pi$".format(round(window_2/np.pi,6)))
plt.axhline(y=window_1,color='C0',ls='--',label=r"${}\pi$".format(round(window_1/np.pi,6)))
plt.xlabel(r"sorted $P_{-}$ Wannier band basis index",fontsize=20)
plt.ylabel(r"$P_6^-$, $k_z$-directed $\gamma_1^-$",fontsize=20)
plt.xticks(fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.xlim([0,len(np.sort(minus_wbe.flatten()))-1])
plt.ylim([-np.pi,np.pi])
plt.legend(fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/kz_directed_P_minus_Wannier_band_energies_of_P6_with_windows.pdf")
plt.close()

plt.figure(figsize=(6,10.5))
plt.plot(np.sort(plus_wbe.flatten()),'.',color='black')
plt.axhline(y=window_2,color='C1',ls='--',label=r"${}\pi$".format(round(window_2/np.pi,6)))
plt.axhline(y=window_1,color='C0',ls='--',label=r"${}\pi$".format(round(window_1/np.pi,6)))
plt.xlabel(r"sorted $P_{+}$ Wannier band basis index",fontsize=20)
plt.ylabel(r"$P_6^+$, $k_z$-directed $\gamma_1^+$",fontsize=20)
plt.xticks(fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.xlim([0,len(np.sort(plus_wbe.flatten()))-1])
plt.ylim([-np.pi,np.pi])
plt.legend(fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/kz_directed_P_plus_Wannier_band_energies_of_P6_with_windows.pdf")
plt.close()

print("Then do nested spin-resolved Wilson loop along ky")

start_time = timeit.default_timer()
dir2=1 # we have two remaining directions, kx and ky, to choose, and here dir2=1 means the second remaining direction, which is ky
window_list=[window_1,window_2]
minus_in_data=minus_wbbarr.nested_berry_phase(window_list,dir2,contin=False,berry_evals=True,wnum=1)
plus_in_data=plus_wbbarr.nested_berry_phase(window_list,dir2,contin=False,berry_evals=True,wnum=1)
window_list=[window_2,window_1]
minus_out_data=minus_wbbarr.nested_berry_phase(window_list,dir2,contin=False,berry_evals=True,wnum=2)
plus_out_data=plus_wbbarr.nested_berry_phase(window_list,dir2,contin=False,berry_evals=True,wnum=2)
print("--- %s seconds ---\n" % (timeit.default_timer() - start_time))

### Plot out the results for the individual eigenphases of the nested spin-resolved Wilson loop

plt.figure(figsize=(5.2,5))
for i in range(minus_in_data.shape[1]):
    plt.plot(minus_in_data[:,i],'o',color='black')
plt.xlim([0,minus_in_data.shape[0]-1])
plt.ylim([-np.pi,np.pi])
plt.xlabel(r"$k_x$",fontsize=20)
plt.ylabel(r"$\gamma_2^-(k_x,k_z=-\pi)$",fontsize=20)
plt.title(r"$\widetilde{P}_{in}^-$",fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.xticks([0,(minus_in_data.shape[0]-1)/2.0,minus_in_data.shape[0]-1],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/inner_nested_P_minus_Wilson_loop_of_P6_eigenphase.pdf")
plt.close()

plt.figure(figsize=(5.2,5))
for i in range(plus_in_data.shape[1]):
    plt.plot(plus_in_data[:,i],'o',color='black')
plt.xlim([0,plus_in_data.shape[0]-1])
plt.ylim([-np.pi,np.pi])
plt.xlabel(r"$k_x$",fontsize=20)
plt.ylabel(r"$\gamma_2^+(k_x,k_z=-\pi)$",fontsize=20)
plt.title(r"$\widetilde{P}_{in}^+$",fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.xticks([0,(plus_in_data.shape[0]-1)/2.0,plus_in_data.shape[0]-1],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/inner_nested_P_plus_Wilson_loop_of_P6_eigenphase.pdf")
plt.close()

plt.figure(figsize=(5.2,5))
for i in range(minus_out_data.shape[1]):
    plt.plot(minus_out_data[:,i],'o',color='black')
plt.xlim([0,minus_out_data.shape[0]-1])
plt.ylim([-np.pi,np.pi])
plt.xlabel(r"$k_x$",fontsize=20)
plt.ylabel(r"$\gamma_2^-(k_x,k_z=-\pi)$",fontsize=20)
plt.title(r"$\widetilde{P}_{out}^-$",fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.xticks([0,(minus_out_data.shape[0]-1)/2.0,minus_out_data.shape[0]-1],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/outer_nested_P_minus_Wilson_loop_of_P6_eigenphase.pdf")
plt.close()

plt.figure(figsize=(5.2,5))
for i in range(plus_out_data.shape[1]):
    plt.plot(plus_out_data[:,i],'o',color='black')
plt.xlim([0,plus_out_data.shape[0]-1])
plt.ylim([-np.pi,np.pi])
plt.xlabel(r"$k_x$",fontsize=20)
plt.ylabel(r"$\gamma_2^+(k_x,k_z=-\pi)$",fontsize=20)
plt.title(r"$\widetilde{P}_{out}^+$",fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.xticks([0,(plus_out_data.shape[0]-1)/2.0,plus_out_data.shape[0]-1],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/outer_nested_P_plus_Wilson_loop_of_P6_eigenphase.pdf")
plt.close()

### Plot out the results for the summed eigenphases of the nested spin-resolved Wilson loop

plt.figure(figsize=(5.2,5))
plt.plot(np.mod(np.sum(minus_in_data,axis=1)+np.pi,2.0*np.pi)-np.pi,'o',color='black')
plt.xlim([0,minus_in_data.shape[0]-1])
plt.ylim([-np.pi,np.pi])
plt.xlabel(r"$k_x$",fontsize=20)
plt.ylabel(r"$ \mathrm{Im}(\mathrm{ln}(\mathrm{det}[\mathcal{W}_2^-])) (k_x,k_z=-\pi)$",fontsize=20)
plt.title(r"$\widetilde{P}_{in}^-$",fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.xticks([0,(minus_in_data.shape[0]-1)/2.0,minus_in_data.shape[0]-1],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/inner_nested_P_minus_Wilson_loop_of_P6_summed_eigenphase.pdf")
plt.close()

plt.figure(figsize=(5.2,5))
plt.plot(np.mod(np.sum(plus_in_data,axis=1)+np.pi,2.0*np.pi)-np.pi,'o',color='black')
plt.xlim([0,plus_in_data.shape[0]-1])
plt.ylim([-np.pi,np.pi])
plt.xlabel(r"$k_x$",fontsize=20)
plt.ylabel(r"$ \mathrm{Im}(\mathrm{ln}(\mathrm{det}[\mathcal{W}_2^+])) (k_x,k_z=-\pi)$",fontsize=20)
plt.title(r"$\widetilde{P}_{in}^+$",fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.xticks([0,(plus_in_data.shape[0]-1)/2.0,plus_in_data.shape[0]-1],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/inner_nested_P_plus_Wilson_loop_of_P6_summed_eigenphase.pdf")
plt.close()

plt.figure(figsize=(5.2,5))
plt.plot(np.mod(np.sum(minus_out_data,axis=1)+np.pi,2.0*np.pi)-np.pi,'o',color='black')
plt.xlim([0,minus_out_data.shape[0]-1])
plt.ylim([-np.pi,np.pi])
plt.xlabel(r"$k_x$",fontsize=20)
plt.ylabel(r"$ \mathrm{Im}(\mathrm{ln}(\mathrm{det}[\mathcal{W}_2^-])) (k_x,k_z=-\pi)$",fontsize=20)
plt.title(r"$\widetilde{P}_{out}^-$",fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.xticks([0,(minus_out_data.shape[0]-1)/2.0,minus_out_data.shape[0]-1],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/outer_nested_P_minus_Wilson_loop_of_P6_summed_eigenphase.pdf")
plt.close()

plt.figure(figsize=(5.2,5))
plt.plot(np.mod(np.sum(plus_out_data,axis=1)+np.pi,2.0*np.pi)-np.pi,'o',color='black')
plt.xlim([0,plus_out_data.shape[0]-1])
plt.ylim([-np.pi,np.pi])
plt.xlabel(r"$k_x$",fontsize=20)
plt.ylabel(r"$ \mathrm{Im}(\mathrm{ln}(\mathrm{det}[\mathcal{W}_2^+])) (k_x,k_z=-\pi)$",fontsize=20)
plt.title(r"$\widetilde{P}_{out}^+$",fontsize=20)
plt.yticks([-np.pi,0.0,np.pi],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.xticks([0,(plus_out_data.shape[0]-1)/2.0,plus_out_data.shape[0]-1],[r"$-\pi$",r"$0$",r"$\pi$"],fontsize=20)
plt.grid(True)
plt.tight_layout()
plt.savefig(path_data+"/outer_nested_P_plus_Wilson_loop_of_P6_summed_eigenphase.pdf")
plt.close()

print("The results of nested spin-resolved Wilson loop behave as in Figs. 26 (b), (c), (e), (f), (h), and (g) of the Supplementary Appendices of arXiv:2207.10099v1 in which t_d is chosen as 1.0\n")

# end of the code
print("Done")

